using System.Collections;
using System.Threading.Tasks;
using UnityEngine;

public class BaseUnit : MonoBehaviour
{
    public bool Ready;
    public bool Alive;
    public bool Diminished;
    public UnitSpecialRules SR;
    public IAttack Attack;
    public IMove Move;
    public Ancestry Ancestry;
    public UnitType Type;

#nullable enable
    public Space? Occupying;
    public bool? Adv;
#nullable disable

    //properties
    public int Player;
    public bool Side; //1 is player, 0 is DM -- useful while player does not have its own class
    public string Name;

    //Changeable stats
    public int AP;
    public int MP;
    public int bAP;
    public int rAP;
    public int HP;
    public int attacksMade;

    //Stats (default is base)
    [SerializeField] int ATK = 3;    //Attack
    [SerializeField] int DEF = 12;   //Defence
    [SerializeField] int POW = 2;    //Power
    [SerializeField] int TOU = 12;   //Toughness
    [SerializeField] int MOR = 0;    //Morale
    [SerializeField] int COM = 0;    //Command

    [SerializeField] int NoA = 1;    //number of attacks
    [SerializeField] int DMG = 1;    //Damage

    [SerializeField] int MVMT = 1;   //number of spaces of movement per action
    [SerializeField] int size = 6;   //Size
    [SerializeField] int tier = 1;   //unit tier

    //initialise with fields from unitmanager in order to prepare stats + components
    public void Initialise(UnitType type, Ancestry ancestry, int player)
    {
        Type = type;
        Ancestry = ancestry;
        Player = player;
        Name = ancestry.ToString() + " " + type.ToString();
        if (Player > 0) { Side = true; }
        else { Side = false; }
        ModifyStats();
        AddScripts();
        HP = size;
        GetComponentInChildren<StatsManager>().InitialiseStats();
    }
    //Activating unit using turn button will start unit turn
    //action plates generated by methods in other scripts
    //unit will wait until it is no longer activated
    public async void ActivateUnit()
    {
        UnitManager.instance.Active = this;
        Ready = false;
        attacksMade = 0;
        AddActionPoints();
        Move.MovePlate();
        Attack.AttackPlate();
        while (UnitManager.instance.Active = this)
        {
            await Task.Yield();
        }
    }
    void ActionStarted()
    {
        Move.ClearMovePlate();
        Attack.ClearAttackPlate();
    }
    void ActionFinished()
    {
        Move.MovePlate();
        Attack.AttackPlate();
        UnitManager.instance.UnitSelect(UnitManager.instance.Selected);
    }
    void AddActionPoints()
    {
        AP = 1;
        MP = MVMT;
        bAP = 1;
        rAP = 1;
    }
    public void MakeMove(Space space)
    {
        ActionStarted();
        int dist = space.Distance(Occupying, space);
        ChangeSpace(space);
        ChangePosition(new Vector3(space.transform.position.x, space.transform.position.y, -2));
        MP -= dist;
        ActionFinished();
    }
    public void MakeAttack(BaseUnit target)
    {
        ActionStarted();
        AP = 0; //set to 0 as units can only take one action
        if (rollTest(ATK, target.GetStat(Stats.DEF)))
        {
            Debug.Log("hit");
            target.ChangeHP(-1);
            if (rollTest(POW, target.GetStat(Stats.TOU)))
            {
                Debug.Log("damage");
                target.ChangeHP(-DMG);
            }
        }
        attacksMade++;
        ActionFinished();
    }
    public bool CanAttack() //I think this is bugged
    {
        if (CheckAP()) { return true; }
        if (attacksMade == 0) { return false; }
        if (attacksMade < NoA) { return true; }
        else { return false; }
    }
    public async void ActivateSpawning()
    {
        UnitManager.instance.Active = this;
        Move.SpawnPlate();
        while (UnitManager.instance.Active == this)
        {
            await Task.Yield();
        }
    }
    public void Spawn(Space space)
    {
        ChangeSpace(space);
        ChangePosition(new Vector3(space.transform.position.x, space.transform.position.y, -2));
        UnitManager.instance.Active = null;
        Move.ClearSpawnPlate();
    }
    public void Rally()
    {
        if (!rollTest(MOR, 13))
        {
            //TODO: Implement rally
        }
    }
    bool MORTest(int DC)
    {
        SR.MORT();
        return rollTest(MOR, DC);
    }
    bool COMTest(int DC)
    {
        SR.COMT();
        return rollTest(COM, DC);
    }
    //compares die roll plus modifier to a target
    public bool rollTest(int modifier, int target)
    {
        if (GameManager.Instance.dieRoll(20, Adv) + modifier >= target) { Adv = null; return true; }
        else { Adv = null; return false; }
    }
    public void ChangeHP(int dHP)
    {
        HP += dHP;
        CheckHP();
        GetComponentInChildren<StatsManager>().UpdateHP();
    }
    void CheckHP()
    {
        if (HP <= 0) { Perish(); }
        else if (!Diminished && HP <= size / 2)
        {
            if (!MORTest(13))
            {
                ChangeHP(-1);
                Diminished = true;
            }
        }
    }
    public bool CheckAP()
    {
        if (AP > 0) { return true; }
        else { return false; }
    }
    void Perish()
    {
        Alive = false;
        //remove from list of live units??
        Occupying.occupiedBy = null;
        this.gameObject.transform.position = new Vector3(100, 100, 100);
        if (UnitManager.instance.Selected = this)
        {
            UnitManager.instance.Unselect();
        }
    }
    public void ChangeSpace(Space space)
    {
        if (Occupying != null) { Occupying.occupiedBy = null; }
        Occupying = space;
        space.occupiedBy = this;
    }
    public void ChangePosition(Vector3 newPos)
    {
        this.gameObject.transform.position = newPos;
    }
    void AddScripts()
    {
        SR = this.gameObject.AddComponent<UnitSpecialRules>();
        switch (Type)
        {
            case UnitType.Infantry:
                Attack = this.gameObject.AddComponent<InfantryAttack>();
                Move = this.gameObject.AddComponent<FootmenMove>();
                break;
            default:
                break;

        }
    }
    void ModifyStats()
    {
        TypeStatMod();
        AncestryStatMod();
    }
    void TypeStatMod()
    {
        switch (Type)
        {
            case UnitType.Infantry:
                COM += 1;
                break;
            case UnitType.Artillery:
                DEF -= 2;
                TOU -= 4;
                break;
            case UnitType.Cavalry:
                POW += 1;
                TOU -= 2;
                break;
        }
    }
    void AncestryStatMod()
    {
        switch (Ancestry)
        {
            case Ancestry.Human:
                MOR += 1;
                COM += 1;
                break;
            case Ancestry.Elf:
                ATK += 1;
                break;
            case Ancestry.Dwarf:
                if (Type == UnitType.Artillery || Type == UnitType.Cavalry)
                {
                    TOU += 2;
                }
                break;
            default:
                break;
        }
    }
    public int GetTier()
    {
        return tier;
    }
    public int GetStat(Stats stat)
    {
        switch (stat)
        {
            case Stats.ATK: return ATK;
            case Stats.DEF: return DEF;
            case Stats.POW: return POW;
            case Stats.TOU: return TOU;
            case Stats.MOR: return MOR;
            case Stats.COM: return COM;
            case Stats.NoA: return NoA;
            case Stats.DMG: return DMG;
            default: return 0;
        }
    }
}
public enum Stats
{
    ATK,
    DEF,
    POW,
    TOU,
    MOR,
    COM,
    NoA,
    DMG
}